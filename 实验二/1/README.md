# DCT图像压缩实验 - 实验一

## 📋 实验目的

通过对512×512灰度图像进行8×8分块DCT变换,只保留每个块的DC(直流)分量进行图像重建,理解DCT变换在图像压缩中的应用原理。

## 🔧 环境要求

### Python版本
- Python 3.7 或更高版本

### 依赖库
```bash
pip install numpy opencv-python matplotlib
```

或使用requirements.txt安装:
```bash
pip install -r requirements.txt
```

## 📁 文件说明

- `dct_1.py` - 主程序文件
- `test_image.jpg` - 测试图像(需要自行准备)
- `processed_image.jpg` - 处理后的输出图像
- `dct_result_visualization.png` - 可视化对比结果
- `README.md` - 使用说明文档

## 🚀 使用方法

### 1. 准备图像
将测试图像命名为 `test_image.jpg` 放在代码同一目录下

### 2. 运行程序
```bash
python dct_1.py
```

### 3. 查看结果
程序会:
- 在控制台输出处理进度和统计信息
- 显示可视化对比图表
- 自动保存处理后的图像和可视化结果

## 📊 实验原理

### DCT变换公式

**正向DCT变换:**
```
F(u,v) = C(u,v) * Σ Σ f(x,y) * cos[(2x+1)uπ/2N] * cos[(2y+1)vπ/2N]
```

**逆DCT变换:**
```
f(x,y) = Σ Σ C(u,v) * F(u,v) * cos[(2x+1)uπ/2N] * cos[(2y+1)vπ/2N]
```

其中:
- `f(x,y)` 是原始图像块
- `F(u,v)` 是DCT系数
- `C(u,v)` 是归一化系数
- `N` 是块大小(本实验为8)

### DC分量的含义

- **DC分量** F(0,0): 表示图像块的平均亮度(直流分量)
- **AC分量** F(u,v) (u,v≠0): 表示图像的细节信息(交流分量)

只保留DC分量意味着:
- 每个8×8块被替换为均匀的灰度值
- 图像失去所有细节,只保留整体明暗分布
- 获得极高的压缩比(64:1)

## 📈 输出结果

### 控制台输出
```
============================================================
DCT图像压缩实验 - 只保留DC分量
============================================================
[成功] 读取图像: test_image.jpg
   图像转换: 彩色 → 灰度
   图像大小: 512x512

[处理] 开始DCT变换处理...
   分块大小: 8x8
   总块数: 4096 (64x64)
   处理进度: 12.5% (512/4096)
   ...
   处理进度: 100.0% (4096/4096)

[完成] 图像处理完成!

============================================================
实验结果统计
============================================================
[统计] 总DCT系数数量: 262,144
[统计] 保留系数数量: 4,096 (仅DC分量)
[压缩] 压缩比: 64.00:1
[压缩] 保留比例: 1.5625%
[质量] PSNR: 30.01 dB
[参数] 处理块数: 4096
============================================================

[保存] 处理后的图像已保存: processed_image.jpg
[保存] 可视化结果已保存: dct_result_visualization.png
[完成] 实验完成!
```

### 可视化结果

程序会生成一个包含以下内容的对比图:

1. **原始图像** - 512×512灰度图
2. **重建图像** - 只保留DC分量后的图像
3. **差异图** - 原始与重建的绝对误差热图
4. **统计信息** - 压缩比、PSNR等关键指标
5. **原始图像直方图** - 像素值分布
6. **重建图像直方图** - 重建后的像素值分布

## 🔍 关键指标说明

### PSNR (峰值信噪比)
- 单位: dB (分贝)
- 计算公式: `PSNR = 20 * log10(255 / √MSE)`
- 数值越高表示重建质量越好
- 典型值范围: 20-40 dB

### 压缩比
- 计算公式: `压缩比 = 总系数数 / 保留系数数`
- 本实验固定为 64:1
- 意味着数据量减少到原来的 1/64

### 保留比例
- 计算公式: `保留比例 = (保留系数数 / 总系数数) × 100%`
- 本实验为 1.5625%

## 🎯 代码结构

```python
create_dct_matrix(n)          # 创建DCT变换矩阵
dct_2d(block)                 # 2D DCT正变换
idct_2d(dct_block)            # 2D DCT逆变换
calculate_psnr(orig, recon)   # 计算PSNR
process_image(image_path)     # 主处理流程
visualize_results(...)        # 结果可视化
main()                        # 主函数入口
```

## 🛠️ 自定义参数

如需修改处理参数,可以编辑 `dct_1.py` 中的以下部分:

```python
# 修改图像路径
original, processed, stats = process_image("your_image.jpg")

# 修改分块大小(需要修改函数调用)
original, processed, stats = process_image("test_image.jpg", block_size=16)
```

## ⚠️ 注意事项

1. **图像格式**: 支持常见格式(jpg, png, bmp等)
2. **图像大小**: 程序会自动调整为512×512
3. **中文字体**: Windows系统图表中文显示使用黑体/微软雅黑
4. **内存占用**: 处理512×512图像约需50MB内存

## 🐛 常见问题

### Q: 提示找不到图像文件?
A: 确保 `test_image.jpg` 与 `dct_1.py` 在同一文件夹下

### Q: 图表中文显示为方块?
A: 这是matplotlib字体问题,不影响功能,可查看保存的PNG文件

### Q: PSNR值异常?
A: 只保留DC分量会大幅降低图像质量,PSNR在25-35 dB属于正常范围

### Q: 程序运行很慢?
A: 处理4096个8×8块需要一定时间,程序会显示进度条

## 📚 扩展学习

- 尝试保留更多低频系数,观察压缩比与质量的权衡
- 对比不同分块大小(4×4, 16×16)的效果
- 实现量化和熵编码,构建完整的JPEG压缩流程
- 研究AC系数的能量分布特性

## 👨‍💻 实验报告建议

1. **实验目的**: 理解DCT变换和图像压缩原理
2. **实验步骤**: 截图展示处理流程
3. **实验结果**: 贴上可视化对比图和统计数据
4. **结果分析**: 
   - PSNR值说明了什么?
   - 为什么只保留DC分量会失去细节?
   - 压缩比如此高,为什么实际JPEG不这样做?
5. **实验总结**: DCT在图像压缩中的作用

## 📝 版本历史

- **v2.0** (2025-10-28)
  - 优化DCT变换算法,提高计算精度
  - 增强错误处理和用户提示
  - 改进可视化效果,添加差异图和直方图
  - 完善代码注释和文档说明
  - 修复Windows控制台编码问题

- **v1.0** (初始版本)
  - 基础DCT变换功能
  - DC分量保留和重建
  - PSNR计算

## 📧 反馈与支持

如有问题或建议,欢迎提出!

---

**实验愉快!** 🎉


# 实验一：图像处理基础实验

本目录包含两个图像处理基础实验的完整实现。

---

## 📂 目录结构

```
实验一/
├── 直方图增强/
│   ├── histogram_enhancement.py    # 改进后的直方图增强代码
│   ├── image_proceed.py           # 原始代码(含人脸检测)
│   ├── testimg.txt               # 测试图像数据
│   ├── enhanced_image.jpg        # 输出:增强后图像
│   └── histogram_enhancement_result.png  # 输出:可视化结果
│
├── dct变换/
│   ├── dct_transform.py          # 改进后的DCT变换代码
│   ├── testimg.txt               # 测试图像数据
│   ├── dct_result.txt            # 输出:DCT系数
│   └── dct_transform_result.png  # 输出:可视化结果
│
└── README.md                      # 本文件
```

---

## 🎯 实验简介

### 实验1-1: 直方图增强

**目的**: 通过直方图均衡化增强图像对比度

**方法**:
- 全局直方图均衡化(Global Histogram Equalization)
- 自适应直方图均衡化(CLAHE - Contrast Limited Adaptive HE)

**特点**:
- ✅ 手工实现直方图计算
- ✅ 手工实现CDF累积分布函数
- ✅ 支持对比度限制
- ✅ 自适应分块处理

**实验结果**:
```
原始图像: 平均值 64.15, 标准差 54.81
增强图像: 平均值 88.26, 标准差 69.00
对比度提升: 25.9%
```

---

### 实验1-2: DCT变换

**目的**: 理解DCT变换在图像处理中的应用

**方法**:
- 8×8分块DCT变换
- 分析DCT系数分布
- 验证能量集中特性

**特点**:
- ✅ 完全手工实现DCT变换矩阵
- ✅ 不使用scipy.fftpack.dct()
- ✅ 不使用cv2.dct()
- ✅ 详细的系数分布分析

**实验结果**:
```
总块数: 4096 (64×64个8×8块)
DC分量平均: 513.19
AC能量平均: 111.86
能量集中度: 验证了低频集中特性
```

---

## 🚀 快速开始

### 安装依赖

```bash
pip install numpy pillow matplotlib
```

### 运行实验

#### 实验1-1: 直方图增强

```bash
cd 直方图增强
python histogram_enhancement.py
```

**输出**:
- `enhanced_image.jpg` - 增强后的图像
- `histogram_enhancement_result.png` - 6子图可视化结果

#### 实验1-2: DCT变换

```bash
cd dct变换
python dct_transform.py
```

**输出**:
- `dct_result.txt` - DCT系数矩阵
- `dct_transform_result.png` - 6子图可视化结果

---

## 📊 实验对比

### 改进前 vs 改进后

| 方面 | 原始代码 | 改进后代码 |
|------|---------|-----------|
| **直方图增强** |
| 实现方式 | 使用OpenCV | 手工实现 |
| 人脸检测 | ✓ | - |
| 可视化 | 2图 | 6图 |
| 代码行数 | 157行 | 约450行 |
| 统计信息 | 基础 | 详细 |
| **DCT变换** |
| 实现方式 | 使用scipy | 手工实现 |
| DCT函数 | scipy.fftpack.dct | 自己实现 |
| 系数分析 | 无 | 详细分析 |
| 可视化 | 无 | 6图 |
| 代码行数 | 31行 | 约550行 |

---

## 🔬 技术细节

### 直方图增强 - 核心算法

**1. 计算直方图**
```python
hist = np.zeros(256)
for pixel_value in image:
    hist[pixel_value] += 1
```

**2. 计算累积分布函数**
```python
cdf = np.cumsum(hist)
```

**3. 归一化映射**
```python
transform_map[i] = ((cdf[i] - cdf_min) / (total - cdf_min)) * 255
```

**4. 应用变换**
```python
enhanced = transform_map[image]
```

### DCT变换 - 核心公式

**DCT变换矩阵**
```
C[i,j] = α(i) * cos[(2j+1)iπ/(2n)]
α(i) = 1/√n (i=0), √(2/n) (i≠0)
```

**2D DCT**
```
F = C * f * C^T
```

**2D IDCT**
```
f = C^T * F * C
```

---

## 📈 实验结果展示

### 直方图增强

**可视化包含:**
1. 原始图像
2. 增强后图像
3. 统计信息对比
4. 原始图像直方图
5. 增强后图像直方图
6. 累积分布函数(CDF)对比

**主要发现:**
- 标准差从54.81提升到69.00
- 对比度提升25.9%
- 像素值分布更均匀

### DCT变换

**可视化包含:**
1. 原始图像
2. DCT系数图(对数尺度)
3. 统计信息
4. 8×8平均系数分布热图
5. 能量累积曲线
6. 示例8×8块DCT系数

**主要发现:**
- DC分量占主导地位
- 能量集中在低频区域
- 验证了DCT的能量集中特性

---

## 💡 核心改进

### 1. 完全手工实现

**直方图增强:**
- ✅ 自己实现直方图计算
- ✅ 自己实现CDF累积
- ✅ 自己实现灰度映射
- ❌ 不使用cv2.equalizeHist()
- ❌ 不使用cv2.createCLAHE()

**DCT变换:**
- ✅ 自己实现DCT变换矩阵
- ✅ 自己实现2D DCT
- ✅ 自己实现2D IDCT
- ❌ 不使用scipy.fftpack.dct()
- ❌ 不使用cv2.dct()

### 2. 详细的统计分析

**直方图增强:**
- 均值、标准差、范围
- 对比度提升百分比
- 像素分布变化

**DCT变换:**
- DC/AC分量统计
- 能量集中度分析
- 系数分布热图

### 3. 专业的可视化

**统一风格:**
- 6子图布局
- 英文标签(避免字体问题)
- 详细的信息面板
- 高质量输出(150 DPI)

---

## 🎓 学习价值

### 理论收获

1. **直方图均衡化**
   - 理解直方图的物理意义
   - 掌握CDF的计算方法
   - 理解对比度增强的原理
   - 学习自适应处理策略

2. **DCT变换**
   - 理解DCT的数学原理
   - 掌握频域变换的概念
   - 验证能量集中特性
   - 为图像压缩打基础

### 编程技能

1. ✅ NumPy数组操作
2. ✅ 算法从理论到实现
3. ✅ 数据可视化技巧
4. ✅ 代码工程化实践

---

## ⚠️ 注意事项

### 直方图增强

1. **输入格式**: 支持testimg.txt或test_image.jpg
2. **处理时间**: 自适应方法较慢(约30秒)
3. **内存占用**: 约100MB
4. **过度增强**: 可能导致噪声放大

### DCT变换

1. **图像大小**: 必须是8的倍数
2. **处理时间**: 512×512图像约10秒
3. **内存占用**: 约150MB
4. **系数范围**: DCT系数可能很大,使用对数显示

---

## 🔧 自定义参数

### 直方图增强

修改 `main()` 函数中的参数:

```python
# 方法1: 全局均衡化
method = 1

# 方法2: 自适应均衡化
enhanced = adaptive_histogram_equalization(
    image, 
    clip_limit=2.0,    # 对比度限制(1.0-4.0)
    block_size=16      # 分块大小(8,16,32)
)
```

### DCT变换

修改 `main()` 函数中的参数:

```python
# 分块大小
block_size = 8  # 可选: 4, 8, 16, 32
dct_image, stats = process_image_dct(image, block_size=block_size)
```

---

## 📚 扩展学习

### 进阶实验建议

**直方图增强:**
1. 实现局部直方图均衡化
2. 对比全局vs自适应效果
3. 测试不同clip_limit的影响
4. 实现彩色图像的直方图均衡

**DCT变换:**
1. 实现DCT域滤波
2. 测试不同块大小的效果
3. 实现Zig-Zag扫描
4. 结合量化实现简单JPEG编码

### 推荐阅读

1. 《数字图像处理》- Gonzalez (第3章:直方图处理)
2. 《数字图像处理》- Gonzalez (第8章:图像压缩)
3. JPEG标准文档: ITU-T T.81

---

## 🐛 常见问题

### Q: 为什么直方图增强后图像噪声增加?
A: 直方图均衡化会拉伸整个灰度范围,包括噪声。可以:
- 降低clip_limit值
- 先进行降噪处理
- 使用局部均衡化

### Q: DCT系数为什么有负值?
A: DCT系数代表频率分量的幅度和相位,可以是负值。这是正常的。

### Q: 为什么能量集中在低频?
A: 自然图像通常平缓变化较多,急剧变化(高频)较少,所以能量集中在低频部分。

### Q: 处理速度如何优化?
A: 
- 使用更小的block_size
- 减少重叠区域
- 使用NumPy向量化操作(已使用)

---

## 📝 实验报告建议

### 直方图增强

1. **实验目的**: 理解直方图均衡化原理
2. **实验原理**: CDF映射方法
3. **实验步骤**: 列出主要步骤
4. **实验结果**: 贴上可视化图和统计数据
5. **结果分析**: 
   - 对比度如何提升?
   - 直方图形状如何变化?
   - CDF曲线说明了什么?
6. **实验总结**: 直方图均衡化的优缺点

### DCT变换

1. **实验目的**: 理解DCT变换原理
2. **实验原理**: DCT数学公式
3. **实验步骤**: 分块、变换、分析
4. **实验结果**: 贴上系数分布图和能量曲线
5. **结果分析**:
   - DC和AC分量的意义?
   - 能量如何分布?
   - 为什么低频占主导?
6. **实验总结**: DCT在图像压缩中的作用

---

## ✨ 总结

两个实验从不同角度展示了图像处理的基础技术:

**直方图增强** - 空间域处理
- 改善图像视觉效果
- 提高对比度
- 应用于图像预处理

**DCT变换** - 频域处理
- 分析图像频率特性
- 为压缩做准备
- 应用于JPEG/MPEG编码

两个实验都采用了:
- ✅ 完全手工实现核心算法
- ✅ 详细的统计分析
- ✅ 专业的可视化输出
- ✅ 规范的代码文档

**适合人群:**
- 学习图像处理的学生
- 研究图像增强的研究者
- 对底层算法感兴趣的开发者

---

**实验完成时间**: 2025年10月28日  
**代码总行数**: ~1000行  
**文档总字数**: ~3000字  

祝学习愉快! 🎉

